////////////////////// ALUNOS ////////////////////////
//  Odélio Porto Júnior - 12701501                   //
//                                                  //
//                                                  //
//////////////////////////////////////////////////////


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <math.h>

#define TAMANHO 1000
#define true 1
#define false 0
typedef int bool;


//////////////////// STRSEP() ///////////////////////////////////////
char *strsep(char **stringp, const char *delim) {
    char *rv = *stringp;
    if (rv) {
        *stringp += strcspn(*stringp, delim);
        if (**stringp)
            *(*stringp)++ = '\0';
        else
            *stringp = 0; }
    return rv;
}


/////////////////// 1)LISTA LIGADA - FUNÇÕES ////////////////////////




///////////////////  2) ÁRVORE BINÁRIA - FUNÇÕES ////////////////////

/*  LISTA LIGADA */
/*  Armazena as linhas em que cada palavra aparece */

/* 2.1) Data Struct */
typedef struct aux{
    int linha;
    struct aux* prox;
} linhaPalavra;

typedef struct {
    linhaPalavra * inicio;
} listaLinhas;






/* ÁRVORE BINÁRIA */
/* indexar as palavras */

/* 2.2) Data Struct - Nó da árvore */
typedef struct aux1 {
    int numPalavra; // número de vezes que a palavra aparece no texto
    //listaLinhas * listaLinhas;
    char * palavra;
    struct aux1 *esq, *dir;
} NO;

/* 2.3) Inicializização da Árvore */
NO * inicializaArvore() {
    return(NULL);
}

/* 2.4) Criação do Nó */
NO * criaNovoNo(char * palavra) {
    NO * novoNo = (NO*) malloc(sizeof(NO));
    novoNo->numPalavra = 1;
    //novoNo->listaLinhas = METODO_INSERIR_LISTA_LIGADA
    novoNo->palavra;
    novoNo->esq = NULL;
    novoNo->dir = NULL;
}

///////////////////////////////////////////////////////////////////

int main(int argc, char ** argv){

	FILE * in;
	char * linha;
	char * copia_ponteiro_linha;
	char * quebra_de_linha;
	char * palavra;
	char * copiaPalavra;
	int contador_linha;

	//if(argc == 2) {

        char * txt = "texto_ep1.txt"; //>>>>>> OBS >>>>>>> INSERIDO POR MIM

        in = fopen(txt, "r");
		//in = fopen(argv[1], "r");// DÚVIDA: 'argv[1]' corresponde ao arquivo txt?
                                  // Used to open a file to perform various operations (which include reading, writing etc)
                                  // "r"- RETURNS a pointer to the first character in the text

		printf(">>>>> Carregando arquivo...\n");

		contador_linha = 0;
 		linha = (char *) malloc((TAMANHO + 1) * sizeof(char)); // ARRAY de chars

		while(in && fgets(linha, TAMANHO, in)){ // fgets(): reads a line from the specified stream ('in') and stores it into the string pointed ('linha')

			if( (quebra_de_linha = strrchr(linha, '\n')) ) *quebra_de_linha = 0; // strrchr()locates the last occurrence of a character in a string ('\n'). It returns a pointer to the last occurrence in the string
                                                                                // If not found, it returns a null pointer.
                                                                                // If serve para indicar o espaçamento do texto sem caracteres?

			printf("linha %03d: '%s'\n", contador_linha + 1, linha);

			// fazemos uma copia do endereço que corresponde ao array de chars
			// usado para armazenar cada linha lida do arquivo pois a função 'strsep'
			// modifica o endereço do ponteiro a cada chamada feita a esta função (e
			// não queremos que 'linha' deixe de apontar para o inicio do array).

			copia_ponteiro_linha = linha;

            //>>>> OBS >>>>> NESTE WHILE QUE DEVEMOS INSERIR A FUNÇÃO PARA MONTAR A ÁRVORE BINÁRIA
			while( (palavra = strsep(&copia_ponteiro_linha, " ")) ){ // Returns a pointer to the first string sliced from '&copia_ponteiro_linha'

                //copiaPalavra = strdup(palavra);
				// antes de guardar a palavra em algum tipo de estrutura usada
				// para implementar o índice, será necessário fazer uma copia
				// da mesma, uma vez que o ponteiro 'palavra' aponta para uma
				// substring dentro da string 'linha', e a cada nova linha lida
				// o conteúdo da linha anterior é sobreescrito.


            //////////////////////////// LISTA LIGADA ///////////////////////////////////////


            // free(copiaPalavra); //>>>>>> OBS >>>>>>> Verificar se é necessário liberar a memória

            //////////////////////////// ÁRVORE BINÁRIA /////////////////////////////////////


                /* Criação da árvore */
                //NO* raizArvore = inicializaArvore();

                /* Inserção de nó na Árvore */


            free(copiaPalavra); //>>>>>> OBS >>>>>>> Verificar se é necessário liberar a memória

            ///////////////////////////////////////////////////////////////////////////////

           		printf("\t\t'%s'\n", palavra);

			}

			contador_linha++;
		}

		printf(">>>>> Arquivo carregado!\n");

		return 0;
	//}

	return 1;
}
