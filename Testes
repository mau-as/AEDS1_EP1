#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <math.h>

#define TAMANHO 1000
#define true 1
#define false 0
typedef int bool;

//////////////////////////////////////////////////////////////////////
/*  LISTA LIGADA */
/*  Armazena as linhas em que cada palavra aparece */

/* 2.1.1) Data Struct */
typedef struct aux{
    int linha;
    struct aux* prox;
} elementoListaLinhas;

typedef struct {
    elementoListaLinhas * inicio;
} listaLinhas;

/* 2.1.2) Inicilização */
void inicializarLista(listaLinhas * l){
    printf("\nTESTE 1: inicializar listaLinhas\n");
    l->inicio = NULL;
}

/* 2.1.3) Inserção*/
/*Função auxiliar - evitar que seja inserido elemento repetido */
elementoListaLinhas * buscaSequencialExc(listaLinhas * l, int contador_linha, elementoListaLinhas** ant){
    *ant = NULL;
    elementoListaLinhas * atual = l->inicio;

    while ((atual != NULL) && (atual->linha < contador_linha)){
        *ant = atual;
        atual = atual->prox;
    }
    if ((atual != NULL) && (atual->linha == contador_linha)) return atual;
    return NULL;
}

bool inserirElemListaOrd(listaLinhas * l, int contador_linha){
    //TIPOCHAVE ch = reg.chave;
    elementoListaLinhas * ant;
    elementoListaLinhas * i;

    i = buscaSequencialExc(l, contador_linha, &ant);
    if (i != NULL) {
            printf("\n >>>>>>>>>>> Elemento %d nao inserido\n", contador_linha);
            return false;
    }

    i = (elementoListaLinhas*) malloc(sizeof(elementoListaLinhas));
    i->linha = contador_linha;

    if (ant == NULL){ // acertar os ponteiros
        printf("\nAnt == NUll esta funcionando\n");
        i->prox = l->inicio;
        l->inicio = i;
    }
    else {
        i->prox = ant->prox;
        ant->prox = i;
    }
    return true;
}

/* 3) Exibir elementos */
void exibirLista(listaLinhas * l){
    elementoListaLinhas * end = l->inicio;
    printf("\nLista: \" ");
    while (end != NULL){
        printf("%i ", end->linha);
        end = end->prox;
    }
    printf("\"\n");
}


/////////////////////////////////////////////////////////////////////


/* ÁRVORE BINÁRIA */
/* indexar as palavras */

/* 2.2) Data Struct - Nó da árvore */
typedef struct aux1 {
    int numPalavra; // número de vezes que a palavra aparece no texto
    //listaLinhas * listaLinhas;
    char * palavra;
    struct aux1 *esq, *dir;
} NO;

/* 2.3) Inicializização da Árvore */
NO * inicializaArvore() {
    return(NULL);
}

/* 2.4) Criação do Nó */
NO * criaNovoNo(char * palavra) {
    NO * novoNo = (NO*) malloc(sizeof(NO));
    novoNo->numPalavra = 1;
    //novoNo->listaLinhas = METODO_INSERIR_LISTA_LIGADA
    novoNo->palavra = strdup(palavra);
    novoNo->esq = NULL;
    novoNo->dir = NULL;
}

/*Insere Nó*/
NO * adiciona(NO * raiz, NO * no){ // insere um nó já existente
    if (raiz == NULL) return(no); // árvore vazia

    int comparacao = strcasecmp(no->palavra, raiz->palavra); //

    if(comparacao == 0){
        raiz->numPalavra += 1; //atualiza o contador se a palavra é igual
    }
    else if (comparacao < 0)
        raiz->esq = adiciona(raiz->esq, no);
    else
        raiz->dir = adiciona(raiz->dir, no);
    return (raiz);
}

/*
node *insertNode(node *root, const char *key) {
    if (!root)
        return newnode(key);

    int cmp = strcmp(key, root->key);
    if (cmp < 0)
        root->left = insertNode(root->left, key);
    else
    if (cmp > 0)
        root->right = insertNode(root->right, key);
    return root;
}
*/


/* Imprimir - UNIVESP */
void exibirArvore(NO* raiz){
    if (raiz != NULL){
        printf("%s", raiz->palavra);
        printf("(");
        exibirArvore(raiz->esq);
        exibirArvore(raiz->dir);
        printf(")");
    }
}


/*Imprimir - USP*/
void imprime_rec(NO * no){

	// percurso in-ordem para a impressão dos elementos

	if(no){
		imprime_rec(no->esq);
		printf("%s", no->palavra);
		imprime_rec(no->dir);
	}
}

void imprime(NO * raiz){

	printf("Elementos na arvore:");
	imprime_rec(raiz);
	printf("\n");
}

int main(){

    int n = 0;
    char * pal1 = "Dd";
    char * pal2 = "Bb";
    char * pal3 = "Aa";
    char * pal4 = "Cc";
    char * pal5 = "Ff";
    char * pal6 = "Ee";
    char * pal7 = "Gg";

    char * pal8 = "Dd";


    NO * raizArvore = inicializaArvore();

    NO * novoNo1 = criaNovoNo(pal1); // D
    raizArvore = adiciona(raizArvore, novoNo1);
    NO * novoNo5 = criaNovoNo(pal5);// F
    raizArvore = adiciona(raizArvore, novoNo5);
    NO * novoNo2 = criaNovoNo(pal2);
    raizArvore = adiciona(raizArvore, novoNo2); // B



    NO * novoNo3 = criaNovoNo(pal3); // A
    raizArvore = adiciona(raizArvore, novoNo3);
    NO * novoNo4 = criaNovoNo(pal4);
    raizArvore = adiciona(raizArvore, novoNo4); // C


    NO * novoNo6 = criaNovoNo(pal6);
    raizArvore = adiciona(raizArvore, novoNo6); // E
    NO * novoNo7 = criaNovoNo(pal7);
    raizArvore = adiciona(raizArvore, novoNo7); // G

    NO * novoNo8 = criaNovoNo(pal8);
    raizArvore = adiciona(raizArvore, novoNo8); // G

    exibirArvore(raizArvore);

    printf("\n\nO numero de vezes que %s aparece e: %d\n\n", raizArvore->palavra, raizArvore->numPalavra);

    exibirArvore(raizArvore);
    printf("\n\n");

    //////////TESTE LISTALINHAS //////////////
    listaLinhas * l = (listaLinhas*) malloc(sizeof(listaLinhas));

    inicializarLista(l);
    if (l->inicio == NULL) printf("\nTESTE 2: A listaLinhas e vazia\n");

    int contador_linha1 = 1;
    int contador_linha2 = 2;
    int contador_linha3 = 3;
    int contador_linha4 = 1;

    inserirElemListaOrd(l, contador_linha1);
    printf("\nTESTE 3: O elemento 1 da listaLinhas e: %d\n", l->inicio->linha);

    inserirElemListaOrd(l, contador_linha2);
    elementoListaLinhas * atual = l->inicio;
    atual = atual->prox;
    printf("\nTESTE 4: O elemento 2 da listaLinhas e: %d\n", atual->linha);

    inserirElemListaOrd(l, contador_linha3);
    atual = atual->prox;
    printf("\nTESTE 5: O elemento 3 da listaLinhas e: %d\n", atual->linha);

    printf("\nTentar inserir elemento repetido\n");
    inserirElemListaOrd(l, contador_linha4);

    atual = atual->prox;
    if (atual != NULL) printf("\nTESTE 6: O elemento 4 nao existe\n");

    exibirLista(l);

}


    /*char * testePalavra = "Odelio";
    char * teste2 = "nulo";

    printf("testePalavra e: %s\n", testePalavra);
    printf("teste2 e: %s\n", teste2);

    //teste2 = strdup(testePalavra);
    //strcpy(teste2, testePalavra);
    teste2 = testePalavra;
    testePalavra = "ERROR";

    printf("O novo teste2 e: %s\n", teste2);
    printf("O novo testepalavra e: %s\n", testePalavra);*/

