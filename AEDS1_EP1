////////////////////// ALUNOS ////////////////////////
//  Odélio Porto Júnior - 12701501                   //
//                                                  //
//                                                  //
//////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <math.h>
#include <time.h>

#define TAMANHO 1000
#define true 1
#define false 0
typedef int bool;


//////////////////// STRSEP() /////////////////////////////////////////////
char *strsep(char **stringp, const char *delim) {
    char *rv = *stringp;
    if (rv) {
        *stringp += strcspn(*stringp, delim);
        if (**stringp)
            *(*stringp)++ = '\0';
        else
            *stringp = 0; }
    return rv;
}


/////////////////// 1) INDEXADOR I - LISTA LIGADA /////////////////////////

                            // Completar //


///////////////////  2) INDEXADOR II - ÁRVORE BINÁRIA /////////////////////


/* 2.1) FUNÇÕES - LISTA LIGADA AUXILIAR */
/* Para armazenar as linhas em que cada palavra aparece */

/* 2.1.1) Data Struct */
typedef struct aux{
    int linha;
    struct aux* prox;
} elementoListaLinhas;

typedef struct {
    elementoListaLinhas * inicio;
} listaLinhas;

/* 2.1.2) Inicilização */
void inicializarLista(listaLinhas * l){
    l->inicio = NULL;
}

/* 2.1.3) Inserção*/
/*Função auxiliar - evitar que seja inserido elemento repetido */
elementoListaLinhas * buscaSequencialExc(listaLinhas * l, int contador_linha, elementoListaLinhas** ant){
    *ant = NULL;
    elementoListaLinhas * atual = l->inicio;

    while ((atual != NULL) && (atual->linha < contador_linha)){
        *ant = atual;
        atual = atual->prox;
    }
    if ((atual != NULL) && (atual->linha == contador_linha)) return atual;
    return NULL;
}

bool inserirElemListaOrd(listaLinhas * l, int contador_linha){
    elementoListaLinhas * ant;
    elementoListaLinhas * i;

    i = buscaSequencialExc(l, contador_linha, &ant);
    if (i != NULL) {
            return false;
    }

    i = (elementoListaLinhas*) malloc(sizeof(elementoListaLinhas));
    i->linha = contador_linha;

    if (ant == NULL){
        i->prox = l->inicio;
        l->inicio = i;
    }
    else {
        i->prox = ant->prox;
        ant->prox = i;
    }
    return true;
}

/* 2.1.4) Imprimir */
void exibirLista(listaLinhas * l){
    elementoListaLinhas * end = l->inicio;
    printf("\nLista: \" ");
    while (end != NULL){
        printf("%i ", end->linha);
        end = end->prox;
    }
    printf("\"\n");
}

/*--------------------------------------------------------------*/

/* 2.2) FUNÇÕES - ÁRVORE BINÁRIA*/
/* Indexar palavras nos nós (sem repetição) */

/* 2.2.1) Data Struct - Nó da árvore */
typedef struct aux1 {
    int numPalavra; // número de vezes que a palavra aparece no texto
    listaLinhas * listaLinhas; // armazenar as linhas em que a palavra aparece (lista ligada)
    char * palavra;
    struct aux1 *esq, *dir;
} NO;

/* 2.2.2) Inicializização da Árvore */
NO * inicializaArvore() {
    return(NULL);
}

/* 2.2.3) Criação do Nó */
NO * criaNovoNo(char * palavra, int contador_linha2) {
    NO * novoNo = (NO*) malloc(sizeof(NO));
    novoNo->palavra = strdup(palavra);
    novoNo->numPalavra = 1;
    novoNo->esq = NULL;
    novoNo->dir = NULL;

    listaLinhas* inicListaLinhas = (listaLinhas*) malloc(sizeof(listaLinhas)); // lista ligada p/ armazenar as linhas em que a palavra aparece
    elementoListaLinhas * element = (elementoListaLinhas*) malloc(sizeof(elementoListaLinhas));
    element->linha = contador_linha2;
    element->prox = NULL;
    inicListaLinhas->inicio = element;

    novoNo->listaLinhas = inicListaLinhas;
}

/* 2.2.4) Insere Nó*/
NO * adiciona(NO * raiz, NO * no, int contador_linha){
    if (raiz == NULL) return(no);

    int comparacao = strcasecmp(no->palavra, raiz->palavra);
    if(comparacao == 0){
        raiz->numPalavra += 1; //atualiza o contador se a palavra é repetida
        inserirElemListaOrd(raiz->listaLinhas, contador_linha); // armazena a linha na qual a palavra repetida está
    }
    else if (comparacao < 0)
        raiz->esq = adiciona(raiz->esq, no, contador_linha);
    else
        raiz->dir = adiciona(raiz->dir, no, contador_linha);
    return (raiz);
}

/* 2.2.5) Busca Binária */
NO * buscaBinaria(char * palavraBuscada, NO * raiz){ //<<<<<<<<<<<<<<<<<<<<<<<<<<<< BUSCA

    if (raiz == NULL) return(NULL);

    int comparacao = strcasecmp(palavraBuscada, raiz->palavra);
    if (comparacao == 0) return (raiz);
    if (comparacao < 0) return buscaBinaria (palavraBuscada, raiz->esq);
    return buscaBinaria (palavraBuscada, raiz->dir);
}

/* 2.2.6) Imprimir */
void exibirArvore(NO* raiz){
    if (raiz != NULL){
        printf("%s", raiz->palavra);
        printf("(");
        exibirArvore(raiz->esq);
        exibirArvore(raiz->dir);
        printf(")");
    }
}


//////////////////////// 3) MAIN ////////////////////////////////////////

int main(int argc, char ** argv){

	FILE * in;
	char * linha;
	char * copia_ponteiro_linha;
	char * quebra_de_linha;
	char * palavra;
	char * copiaPalavra;
	char tipoEstrutura[7];
	char * txt;
	int contador_linha;
	double tempoGastoIns = 0.0;
	double tempoGastoBusca = 0.0;
    NO * raiz = inicializaArvore();
    NO * tempNO;

	//if(argc == 2) {

    printf("\nEscolhae o tipo de estrutura (1) lista ou (2) arvore: "); // >>>>>>>>>> IMPLEMENTAR -> Passar para tipoEstrutura o argv[1]
    scanf("%s", tipoEstrutura);
    printf("\nEscolhido: %s\n", tipoEstrutura);

    char * escolhaLista = "lista";
    int resultadoEstr = strcasecmp(escolhaLista, tipoEstrutura);


    //////////// <CRIAÇÃO ÁRVORE > //////////////////////////////////////////

    clock_t inicioCarrega = clock(); //<<<<<<<<<<<<<<<<<<<<< CLOCK
    if (resultadoEstr != 0){

        txt = "texto_ep1.txt"; // >>>>>>>>>> IMPLEMENTAR -> Passar para tipoEstrutura o argv[1]
        in = fopen(txt, "r");
		//in = fopen(argv[1], "r");// >>>>>> DÚVIDA: 'argv[1]' corresponde ao arquivo txt?

		printf(">>>>> Carregando arquivo...\n");

		contador_linha = 0;
 		linha = (char *) malloc((TAMANHO + 1) * sizeof(char)); // ARRAY de chars

		while(in && fgets(linha, TAMANHO, in)){

			if( (quebra_de_linha = strrchr(linha, '\n')) ) *quebra_de_linha = 0;

			printf("linha %03d: '%s'\n", contador_linha + 1, linha);

			copia_ponteiro_linha = linha;

			while( (palavra = strsep(&copia_ponteiro_linha, " ")) ){

                copiaPalavra = strdup(palavra);

                /* Criação da Árvore */
                int contador_linha2 = contador_linha + 1; //indica qual a linha a palavra está, para inclusão na lista ligada das linhas
                tempNO = criaNovoNo(copiaPalavra, contador_linha2);
                raiz = adiciona(raiz, tempNO, contador_linha2);

           		printf("\t\t'%s'\n", palavra);

			}

			contador_linha++;
		 }

		 printf(">>>>> Arquivo carregado na Arvore!\n");

 		//return 0;
    }
    clock_t fimCarrega  = clock();
	tempoGastoIns = (double)(fimCarrega - inicioCarrega) / CLOCKS_PER_SEC; //<<<<<<<<<<<<<<<<<<<<< CLOCK
    tempoGastoIns = tempoGastoIns * 1000;

    //////////////////////////// CRIAÇÃO LISTA LIGADA ///////////////////////////////////////////////////

        // else {
        //}

    //////////////////////////// 4) IF - BUSCA ARVORE / ELSE - LISTA ////////////////////////////////////////

    printf("\n\nTipo de indice: 'arvore'\n");
    printf("Arquivo texto: '%s'\n", txt); // >>>>>>>>>> IMPLEMENTAR -> Passar para tipoEstrutura o argv[1]
    printf("Numero de linhas no arquivo: %d\n", contador_linha);
    printf("Tempo para carregar o arquivo e construir o indice: %.3f ms\n", tempoGastoIns);

    char * palavraFimLoop = "fim";
    char * comandoBusca = "busca";
    char palavraBuscada[50];
    char comando_digitado[6];
    int resultaDoEstr = 1;
    int * pResultaDoEstr = &resultaDoEstr;

    do{
        printf("> ");
        scanf("%s", comando_digitado);

        *pResultaDoEstr = strcasecmp(palavraFimLoop, comando_digitado);

        if (*pResultaDoEstr == 0)
            return 0;

        else if ( strcasecmp(comandoBusca, comando_digitado) == 0 ){
            printf(" > Digite a palavra buscada: ");
            scanf("%s", &palavraBuscada);
            NO * noResultadoBusca = buscaBinaria(palavraBuscada, raiz);

            if (noResultadoBusca == NULL)
                printf("Palavra '%s' nao encontrada",palavraBuscada);

            else if (noResultadoBusca != NULL)
                printf ("Existem %d ocorrencias da palavra '%s' na(s) seguinte(s) linha(s):\n", noResultadoBusca->numPalavra, noResultadoBusca->palavra);

            //int c = 0; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Imprimir as linhas
            //while (c < noResultadoBusca-> numPalavra){
                 // >>>>>>>>>>>> INCLUIR - imprimir as linhas
            //}
        }
        else
            printf("Opcao invalida!");

    } while (*pResultaDoEstr != 0);


	//}
	return 1;
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}




